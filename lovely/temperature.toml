[manifest]
version = "1.0.0"
dump_lua = true
priority = 1

# Temperature 1/ - Game:init_game_object()
[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = 'inflation = 0,'
position = 'after'
match_indent = true
payload = '''opal_temperature = 0,
opal_temp_level = 0,'''

# Temperature 2/ - Game:start_run(args)
[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = 'self.GAME.dollars = self.GAME.starting_params.dollars'
position = 'after'
match_indent = true
payload = '''self.GAME.opal_temperature = self.GAME.starting_params.opal_temperature
self.GAME.opal_temp_level = self.GAME.starting_params.opal_temp_level
self.GAME.modifiers.opal_no_heat = self.GAME.modifiers.opal_no_heat or (not OPAL.config.heat_system)
self.GAME.modifiers.opal_no_mods = self.GAME.modifiers.opal_no_mods or (not OPAL.config.modifiers)
self.GAME.opal_ry_scaling = {}'''

# Temperature 3/ - get_starting_params()
[[patches]]
[patches.pattern]
target = 'functions/misc_functions.lua'
pattern = 'dollars = 4,'
position = 'after'
match_indent = true
payload = '''opal_temperature = 0,
opal_temp_level = 0,'''

# Temperature 4/ - Create temperature UI at start of game
[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = 'G.playing_cards = {}'
position = 'before'
match_indent = true
payload = '''if not (G.GAME.modifiers.opal_no_heat and G.GAME.modifiers.opal_no_mods) then
                G.opal_temperature_UI = UIBox{
                    definition = create_uibox_opal_temperature(), 
                    config = {align="cli", offset = {x=OPAL.get_temp_x(),y=1.7}, major = G.ROOM_ATTACH, bond = 'Weak', instance_type = 'CARD'}
                }
                G.opal_heat_mods.config.opal_type = G.opal_mod_shape == 1 and 'hex' or 'square'
                G.opal_heat_mods.config.opal_size = G.opal_mod_size == 1 and 1 or 1.35
                if not G.GAME.modifiers.opal_no_mods then G.E_MANAGER:add_event(Event({trigger = 'after', func = function() OPAL.update_modifier_menu() ;return true end })) end
OPAL.add_indicators()
end'''

# Temperature 5/ - Create Heat for hands above blind requirement
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
pattern = '''if G.GAME.modifiers.debuff_played_cards then'''
position = 'before'
match_indent = true
payload = '''G.GAME.modifiers.opal_heat_increase = G.GAME.modifiers.opal_heat_increase or 0
if (not(G.GAME.modifiers.opal_no_heat)) and hand_chips*mult > G.GAME.blind.chips then
    G.GAME.modifiers.opal_heat_increase = math.min((math.floor(math.log((hand_chips*mult / G.GAME.blind.chips), 2)+1)), 10)
end'''

# Temperature 6/ - Remove Temperature when run is kill...
[[patches]]
[patches.pattern]
target = 'game.lua'
pattern = '''if self.GAME_OVER_UI then self.GAME_OVER_UI:remove(); self.GAME_OVER_UI = nil end'''
position = 'before'
match_indent = true
payload = '''if self.opal_temperature_UI then self.opal_temperature_UI:remove(); self.opal_temperature_UI = nil end'''

# Temperature 7/ - saving
[[patches]]
[patches.pattern]
target = 'functions/misc_functions.lua'
position = 'before'
pattern = '''local tags = {}'''
payload = '''local mods = {}
if G.opal_heat_mods then
for k, v in ipairs(G.opal_heat_mods.cards) do
    if (type(v) == "table") then 
        local modSer = v.config.center.key
        if modSer then mods[k] = modSer end
    end
end
end'''
match_indent = true

# Temperature 8/ - saving
[[patches]]
[patches.pattern]
target = 'functions/misc_functions.lua'
position = 'before'
pattern = '''tags = tags,'''
payload = '''mods = mods,'''
match_indent = true

# Temperature 9/ - Add Heat for end of round
[[patches]]
[patches.pattern]
target = 'functions/state_events.lua'
position = 'after'
pattern = '''-- TARGET: main end_of_round evaluation'''
payload = '''OPAL.ease_temp(G.GAME.modifiers.opal_heat_per_round + G.GAME.modifiers.opal_heat_increase)
G.GAME.modifiers.opal_heat_increase = 0'''
match_indent = true

# Rewards 1/ - eval_card()
[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
position = 'before'
pattern = '''-- TARGET: evaluate your own general effects'''
payload = '''if G.opal_heat_mods and context.cardarea == G.opal_heat_mods and card.ability.set == 'OpalModifier' then
        local jokers = nil
        if context.other_joker and type(context.other_joker.calculate) == 'function' then
            jokers = context.other_joker.config.center:calculate(card, context)
        elseif type(card.calculate) == 'function' then
            jokers = card.config.center:calculate(card, context)
        end
        if jokers then 
            ret.jokers = jokers
        end
    end'''
match_indent = true

# Rewards 2/ - add modifiers to joker calcs
[[patches]]
[patches.pattern]
target = """=[SMODS _ "src/utils.lua"]"""
position = 'after'
pattern = '''-- TARGET: add your own CardAreas for joker evaluation'''
payload = '''
if G.opal_heat_mods and G.opal_heat_mods.cards then table.insert(t, G.opal_heat_mods) end
'''
match_indent = true

# Rewards 3/ - show badges in collection
[[patches]]
[patches.pattern]
target = 'functions/UI_definitions.lua'
pattern = """if card.config and card.config.tag then
              SMODS.create_mod_badges(SMODS.Tags[card.config.tag.key], badges)
          end"""
position = 'after'
payload = """
if card.config and card.config.modifier then
    SMODS.create_mod_badges(OPAL.Modifiers[card.config.modifier.key], badges)
end"""
match_indent = true

# Rewards 4/ - Running Yolk
[[patches]]
[patches.pattern]
target = """=[SMODS _ "src/utils.lua"]"""
pattern = """local scalar_value = args.scalar_table[args.scalar_value]"""
position = 'after'
payload = """if G.GAME.opal_ry_scaling[args.ref_value] and scalar_value > 0 then scalar_value = scalar_value * (2^G.GAME.opal_ry_scaling[args.ref_value]) end"""
match_indent = true

# Rewards 5/ - Check for debuff
[[patches]]
[patches.pattern]
target = "blind.lua"
pattern = """for _, v in ipairs(G.playing_cards) do
        self:debuff_card(v)
    end"""
position = 'after'
match_indent = true
payload = """if G.opal_heat_mods and G.opal_heat_mods.cards then
    for _, v in ipairs(G.opal_heat_mods.cards) do
        self:debuff_card(v)
    end
end"""

# Rewards 6/ - Debuff stuff
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = """if self.area == G.jokers then if should_debuff then self:remove_from_deck(true) else self:add_to_deck(true) end end"""
position = 'after'
match_indent = true
payload = """if G.opal_heat_mods and self.area == G.opal_heat_mods then 
    _center = self.config.center
    if should_debuff then
        _center:unapply(self)
    elseif self.debuff then
        _center:apply(self)
    end
end"""

# Rewards 7/ - cardarea shenanigans
[[patches]]
[patches.pattern]
target = 'cardarea.lua'
pattern = '''if self.config.type == 'deck' then 
            for i = #self.cards, 1, -1 do'''
position = 'before'
match_indent = true
payload = '''if self.config.type == 'opal_mods' then
    for i = #self.cards, 1, -1 do 
        if self.cards[i] ~= G.CONTROLLER.focused.target then
            if G.CONTROLLER.dragging.target ~= self.cards[i] then self.cards[i]:draw(v) end
        end
    end
end'''

# Rewards 8/ - cardarea shenanigans
[[patches]]
[patches.pattern]
target = 'cardarea.lua'
pattern = '''(self.config.type == 'deck' and self ~= G.deck) or'''
position = 'before'
match_indent = true
payload = '''(self.config.type == 'opal_mods') or'''

# Rewards 9/ - cardarea shenanigans
[[patches]]
[patches.pattern]
target = 'cardarea.lua'
pattern = '''if self.config.type == 'deck' then
            local deck_height = (self.config.deck_height or 0.15)/52'''
position = 'before'
match_indent = true
payload = '''if self.config.type == 'opal_mods' then
    local card_count = 0
    for k, card in ipairs(self.cards) do
        card.opal_count = card_count
        card_count = card_count + 1
    end
    for k, card in ipairs(self.cards) do
        if (not card.states.drag.is) or card == G.lock_in_card then 
            local opal_size = self.config.opal_size or 1
            if self.config.opal_type == 'hex' then
                card.T.r = 0
                card.T.x = self.T.x + (0.58*opal_size)*(math.fmod(card.opal_count, self.config.opal_per_row) - 0.5*math.fmod(math.floor(card.opal_count/self.config.opal_per_row)+2, 2)) - 0.1
                card.T.y = self.T.y + self.T.h/2 - card.T.h/2 + opal_size*0.56*(math.floor(card.opal_count/self.config.opal_per_row))
                card.shadow_parrallax = {x=0, y=0}
            else -- type must be 'square'
                card.T.r = 0
                card.T.x = self.T.x + (0.55*opal_size)*(math.fmod(card.opal_count, self.config.opal_per_row)) - 0.1
                card.T.y = self.T.y + self.T.h/2 - card.T.h/2 + opal_size*0.6*(math.floor(card.opal_count/self.config.opal_per_row))
                card.shadow_parrallax = {x=0, y=0}
            end
        end
    end
end'''

# Rewards 10/ - cardarea shenanigans
[[patches]]
[patches.pattern]
target = 'cardarea.lua'
pattern = '''self.config.card_count = 0'''
position = 'after'
match_indent = true
payload = '''self.config.opal_per_row = config.opal_per_row or 4
self.config.opal_type = config.opal_type or 'square' '''

# DebugPlus stuff for modifiers
[[patches]]
[patches.pattern]
target = 'engine/controller.lua'
pattern = 'debugplus.handleKeys(self, key, dt)'
position = 'before'
match_indent = true
payload = '''OPAL.handleKeys(self, key)'''

# Localization shenanigans 1/
[[patches]]
[patches.pattern]
target = 'functions/misc_functions.lua'
pattern = '''elseif args.type == 'descriptions' or args.type == 'unlocks' then'''
position = 'before'
match_indent = true
payload = '''elseif args.type == 'opal_info' then
    loc_target = G.localization.descriptions.opal_info[args.set][args.key]
    return loc_target'''

# Localization shenanigans 2/
[[patches]]
[patches.pattern]
target = 'functions/common_events.lua'
pattern = '''elseif _c.set == 'Tarot' then'''
position = 'before'
match_indent = true
payload = '''elseif _c.set == 'OpalModifier' then
    localize{type = 'descriptions', key = _c.key, set = _c.set, nodes = desc_nodes, vars = _c.vars or loc_vars}'''

# test
[[patches]]
[patches.pattern]
target = '''functions/button_callbacks.lua'''
pattern = '''card:add_to_deck()
        G[select_to]:emplace(card)
        if card.config.center.on_select and type(card.config.center.on_select) == 'function' then
            card.config.center:on_select(card)
        end
        play_sound('card1', 0.8, 0.6)
        play_sound('generic1')
        dont_dissolve = true
        delay_fac = 0.2'''
position = 'at'
match_indent = true
payload = '''if card.ability.set == 'OpalModifier' then
    card.T.w = card.T.w/2
    card.T.h = card.T.h/2
    local preapp_table = {}
    if card.config.center.pre_apply then preapp_table = card.config.center:pre_apply(card) end
    
    if preapp_table and preapp_table['type'] == 'item' then
        card.config.center:set_item(card, preapp_table['item'])
    end

    local merge_instead = nil
    for k, v in ipairs(G.opal_heat_mods.cards) do
        if v.ability.opal_count and v.config.center == card.config.center and v.config.center.merge and
            (not preapp_table['type'] or preapp_table['type'] == 'item' and preapp_table['item'] == v.ability.extra) then
            merge_instead = k
        end
    end
    OPAL.existing_modifiers = OPAL.existing_modifiers or {}
    OPAL.existing_modifiers[card.config.center.key] = true
    if merge_instead then
        G.opal_heat_mods.cards[merge_instead].config.center:merge(G.opal_heat_mods.cards[merge_instead], 1)
        G.opal_heat_mods.cards[merge_instead].ability.opal_count = G.opal_heat_mods.cards[merge_instead].ability.opal_count + 1
        G.opal_heat_mods.cards[merge_instead]:juice_up()
        SMODS.destroy_cards(card, nil, nil, nil)
        if G.opal_heat_mods.cards[merge_instead].children.opal_md_counter then G.opal_heat_mods.cards[merge_instead].children.opal_md_counter:remove() end
            G.opal_heat_mods.cards[merge_instead].children.opal_md_counter = UIBox{
            definition = {n = G.UIT.R, config = {colour = G.C.BLACK, align = "cm", padding = 0.05, r = 0.1}, nodes = {
                {n=G.UIT.T, config = {text = tostring(G.opal_heat_mods.cards[merge_instead].ability.opal_count), scale = 0.3, colour = G.C.WHITE}}
            }},
            config = {align = "br", offset = {x=-0.3, y=-0.35}, parent = G.opal_heat_mods.cards[merge_instead]}
            }
    else
        card:add_to_deck()
        G.opal_heat_mods:emplace(card)
        card.config.center:apply(card)
        card.ability.opal_count = 1
        card.ability.opal_md_temp_decrease = 0
        dont_dissolve = true
    end
    OPAL.update_modifier_menu()
    play_sound('holo1', 1.2 + math.random() * 0.1, 0.4)
    delay_fac = 0.2
else
    card:add_to_deck()
    G[select_to]:emplace(card)
    if card.config.center.on_select and type(card.config.center.on_select) == 'function' then
        card.config.center:on_select(card)
    end
    play_sound('card1', 0.8, 0.6)
    play_sound('generic1')
    dont_dissolve = true
    delay_fac = 0.2
end'''